# Задача "Понимание JVM"

###Описание процесса:

```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```
###1. Начинаем с поиска и загрузки классов:

Application ClassLoader -> Platform Classloader - > Bootstrap ClassLoader.
Каждый Classloader ищет в кэше требуемый класс и делегирует загрузку родителю. Загрузка начинается с Bootstrap ClassLoader и заканчивается в Application ClassLoader, т.е. в обратном направлении.
Думаю, что наш класс JvmComprehension как раз загружается последним.
###2. Следующим этапом идет "Связывание (Linking)"

Тут происходит подготовка классов к выполнению. Linking так же состоит из 3х этапов Verify -> Prepare -> - Resolve.
На этапе Resolve происходит связывание ссылок на другие классы, по этому, если в нашем классе есть ссылка на другой класс, который еще не был подгружен, заново проваливаемся в пункт №1 и подгружаем недостающее.

Далее идет Инициализация статических методов и статических полей, после которой они будут доступны.

###3. Загрузка классов осуществляется в следующие области памяти: 
- **Metaspaсe** (Информация о другой информации) - здесь хранится информация о классах (о типе, методах, статических полях и статических переменных) 
- **Heap (куча)** - здесь хранятся объекты, созданные в программе. К этому относятся и версии объектов примитивных типов (например, Byte, Integer, Long и т. д.)
- **Stack** - здесь хранятся все локальные переменные для каждого выполняемого метода (создается отдельный фрейм), а так же все примитивы (int, double, char и т.д..), ссылки на объекты.

##В приложенном изображении показана схема заполнения областей памяти (как я это понял).
Сомнения вызывают пункты №№ 6 и 7. 
- Нужно ли для метода toString выделять в стэке отдельный фрейм? (пункт 6)
- Посмотрел реализацию метода println класса PrintStream - он как бы void, но параметром у него String x. Отсюда в стэке X, а в куче String("finished"). (пункт 7)